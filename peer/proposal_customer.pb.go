// Code generated by protoc-gen-go. DO NOT EDIT.
// source: peer/proposal_customer.proto

package peer

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// A Proposal is sent to an endorser for endorsement.  The proposal contains:
// 1. A header which should be unmarshaled to a Header message.  Note that
//    Header is both the header of a Proposal and of a Transaction, in that i)
//    both headers should be unmarshaled to this message; and ii) it is used to
//    compute cryptographic hashes and signatures.  The header has fields common
//    to all proposals/transactions.  In addition it has a type field for
//    additional customization. An example of this is the ChaincodeHeaderExtension
//    message used to extend the Header for type CHAINCODE.
// 2. A payload whose type depends on the header's type field.
// 3. An extension whose type depends on the header's type field.
//
// Let us see an example. For type CHAINCODE (see the Header message),
// we have the following:
// 1. The header is a Header message whose extensions field is a
//    ChaincodeHeaderExtension message.
// 2. The payload is a ChaincodeProposalPayload message.
// 3. The extension is a ChaincodeAction that might be used to ask the
//    endorsers to endorse a specific ChaincodeAction, thus emulating the
//    submitting peer model.
type ProposalCustomer struct {
	// The header of the proposal. It is the bytes of the Header
	Header []byte `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	// The payload of the proposal as defined by the type in the proposal
	// header.
	Payload []byte `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`
	// Optional extensions to the proposal. Its content depends on the Header's
	// type field.  For the type CHAINCODE, it might be the bytes of a
	// ChaincodeAction message.
	Extension []byte `protobuf:"bytes,3,opt,name=extension,proto3" json:"extension,omitempty"`
	// invoke is true mean invoke, invoke is false mean query
	Invoke bool `protobuf:"varint,4,opt,name=invoke,proto3" json:"invoke,omitempty"`
	// Those nodes must be executed
	Nodes                []string `protobuf:"bytes,5,rep,name=nodes,proto3" json:"nodes,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ProposalCustomer) Reset()         { *m = ProposalCustomer{} }
func (m *ProposalCustomer) String() string { return proto.CompactTextString(m) }
func (*ProposalCustomer) ProtoMessage()    {}
func (*ProposalCustomer) Descriptor() ([]byte, []int) {
	return fileDescriptor_97f2c3339744c08b, []int{0}
}

func (m *ProposalCustomer) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ProposalCustomer.Unmarshal(m, b)
}
func (m *ProposalCustomer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ProposalCustomer.Marshal(b, m, deterministic)
}
func (m *ProposalCustomer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProposalCustomer.Merge(m, src)
}
func (m *ProposalCustomer) XXX_Size() int {
	return xxx_messageInfo_ProposalCustomer.Size(m)
}
func (m *ProposalCustomer) XXX_DiscardUnknown() {
	xxx_messageInfo_ProposalCustomer.DiscardUnknown(m)
}

var xxx_messageInfo_ProposalCustomer proto.InternalMessageInfo

func (m *ProposalCustomer) GetHeader() []byte {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *ProposalCustomer) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *ProposalCustomer) GetExtension() []byte {
	if m != nil {
		return m.Extension
	}
	return nil
}

func (m *ProposalCustomer) GetInvoke() bool {
	if m != nil {
		return m.Invoke
	}
	return false
}

func (m *ProposalCustomer) GetNodes() []string {
	if m != nil {
		return m.Nodes
	}
	return nil
}

func init() {
	proto.RegisterType((*ProposalCustomer)(nil), "protos.ProposalCustomer")
}

func init() { proto.RegisterFile("peer/proposal_customer.proto", fileDescriptor_97f2c3339744c08b) }

var fileDescriptor_97f2c3339744c08b = []byte{
	// 225 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x4c, 0x8f, 0xb1, 0x4e, 0xc3, 0x30,
	0x10, 0x86, 0x15, 0x4a, 0x0b, 0xb5, 0x90, 0x40, 0x16, 0x42, 0x1e, 0x3a, 0x44, 0x9d, 0xc2, 0x62,
	0x0f, 0xbc, 0x41, 0x79, 0x81, 0x2a, 0x23, 0x0b, 0x38, 0xf1, 0xe1, 0x58, 0x4d, 0x7d, 0xd6, 0xd9,
	0x45, 0xf4, 0x2d, 0x78, 0x64, 0x94, 0xd8, 0x15, 0x4c, 0xd6, 0xe7, 0xbb, 0xef, 0xf4, 0xff, 0x6c,
	0x13, 0x00, 0x48, 0x05, 0xc2, 0x80, 0x51, 0x8f, 0xef, 0xfd, 0x29, 0x26, 0x3c, 0x02, 0xc9, 0x40,
	0x98, 0x90, 0xaf, 0xe6, 0x27, 0x6e, 0x7f, 0x2a, 0xf6, 0xb0, 0x2f, 0x3b, 0xaf, 0x65, 0x85, 0x3f,
	0xb1, 0xd5, 0x00, 0xda, 0x00, 0x89, 0xaa, 0xae, 0x9a, 0xbb, 0xb6, 0x10, 0x17, 0xec, 0x26, 0xe8,
	0xf3, 0x88, 0xda, 0x88, 0xab, 0x79, 0x70, 0x41, 0xbe, 0x61, 0x6b, 0xf8, 0x4e, 0xe0, 0xa3, 0x43,
	0x2f, 0x16, 0xf3, 0xec, 0xef, 0x63, 0xba, 0xe7, 0xfc, 0x17, 0x1e, 0x40, 0x5c, 0xd7, 0x55, 0x73,
	0xdb, 0x16, 0xe2, 0x8f, 0x6c, 0xe9, 0xd1, 0x40, 0x14, 0xcb, 0x7a, 0xd1, 0xac, 0xdb, 0x0c, 0xbb,
	0x0f, 0xb6, 0x45, 0xb2, 0x72, 0x38, 0x07, 0xa0, 0x11, 0x8c, 0x05, 0x92, 0x9f, 0xba, 0x23, 0xd7,
	0xe7, 0xe8, 0x51, 0x4e, 0xc5, 0x76, 0xf7, 0x97, 0xd4, 0x7b, 0xdd, 0x1f, 0xb4, 0x85, 0xb7, 0x67,
	0xeb, 0xd2, 0x70, 0xea, 0x64, 0x8f, 0x47, 0xf5, 0xcf, 0x55, 0xd9, 0x55, 0xd9, 0x55, 0x93, 0xdb,
	0xe5, 0xf2, 0x2f, 0xbf, 0x01, 0x00, 0x00, 0xff, 0xff, 0x8e, 0xf3, 0x26, 0xce, 0x23, 0x01, 0x00,
	0x00,
}
